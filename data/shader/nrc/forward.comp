#version 460
#include "common.glsl"

// Set to nvidia subgroup count
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Row major
ivec2 BatchSampleToImageCoord(const uint batchIndex, const uint sampleIndex)
{
	const uint linearIndex = (batchIndex * BATCH_SIZE) + sampleIndex;
	const uint y = linearIndex / RENDER_WIDTH;
	const uint x = linearIndex % RENDER_WIDTH;
	const ivec2 imageCoord = ivec2(x, y);
	return imageCoord;
}

void LoadNeuralRayFromImages(const ivec2 imageCoord, out vec3 rayOrigin, out vec3 rayDir)
{
	rayOrigin = imageLoad(nrcNeuralRayOriginImage, imageCoord).xyz;
	rayDir = imageLoad(nrcNeuralRayDirImage, imageCoord).xyz;
}

void EncodeRay(const uint sampleIndex, const vec3 rayOrigin, const vec3 rayDir)
{
	const uint startIndex = sampleIndex * INPUT_FEATURE_COUNT;

	// Norm ray origin
	const vec3 normRayOrigin = rayOrigin / skySize;

	// Dir to phi theta
	const float theta = atan(rayDir.z, rayDir.x);
	const float phi = atan(length(rayDir.xz), rayDir.y);

	// Encode pos
	// Always encode direct
	const uint directPosIndex = startIndex;
	neurons[directPosIndex + 0] = normRayOrigin.x;
	neurons[directPosIndex + 1] = normRayOrigin.y;
	neurons[directPosIndex + 2] = normRayOrigin.z;

	// Encode pos frequency
	const uint freqPosIndex = directPosIndex + 3;
	if (POS_ENCODING == 1 || POS_ENCODING == 2)
	{
		for (uint freq = 0; freq < POS_FREQ_COUNT; freq++)
		{
			const float waveScale = pow(2.0, float(freq)) * PI;
			neurons[freqPosIndex + (freq * 6) + 0] = sin(waveScale * normRayOrigin.x);
			neurons[freqPosIndex + (freq * 6) + 1] = cos(waveScale * normRayOrigin.x);
			neurons[freqPosIndex + (freq * 6) + 2] = sin(waveScale * normRayOrigin.y);
			neurons[freqPosIndex + (freq * 6) + 3] = cos(waveScale * normRayOrigin.y);
			neurons[freqPosIndex + (freq * 6) + 4] = sin(waveScale * normRayOrigin.z);
			neurons[freqPosIndex + (freq * 6) + 5] = cos(waveScale * normRayOrigin.z);
		}
	}

	// Encode pos mrhe
	const uint mrhePosIndex = freqPosIndex + (POS_FREQ_COUNT * 6);
	if (POS_ENCODING == 2)
	{
		// TODO
	}

	// Encode dir
	uint directDirIndex = directPosIndex + 3;
	if (POS_ENCODING == 1)
	{
		directDirIndex += POS_FREQ_COUNT * 6;
	}
	else if (POS_ENCODING == 2)
	{
		directDirIndex += (POS_FREQ_COUNT * 6) + (POS_LEVEL_COUNT * POS_FEATURE_COUNT);
	}

	// Encode dir direct
	neurons[directDirIndex + 0] = phi;
	neurons[directDirIndex + 1] = theta;

	// Encode dir freq
	const uint freqDirIndex = directDirIndex + 2;
	if (DIR_ENCODING == 1 || DIR_ENCODING == 2)
	{
		for (uint freq = 0; freq < DIR_FREQ_COUNT; freq++)
		{
			const float waveScale = pow(2.0, float(freq)); // No PI because PI is in phi and theta
			neurons[freqDirIndex + (freq * 4) + 0] = sin(waveScale * phi);
			neurons[freqDirIndex + (freq * 4) + 1] = cos(waveScale * phi);
			neurons[freqDirIndex + (freq * 4) + 2] = sin(waveScale * theta);
			neurons[freqDirIndex + (freq * 4) + 3] = cos(waveScale * theta);
		}
	}

	// Encode dir one blob
	const uint oneBlobDirIndex = freqDirIndex + (DIR_FREQ_COUNT * 4);
	if (DIR_ENCODING == 2)
	{
		for (uint feature = 0; feature < DIR_FEATURE_COUNT; feature++)
		{
			neurons[oneBlobDirIndex + (feature * 2) + 0] = NormGauss(phi, 0.0, ONE_OVER_DIR_FEATURE_COUNT);
			neurons[oneBlobDirIndex + (feature * 2) + 1] = NormGauss(phi, 0.0, ONE_OVER_DIR_FEATURE_COUNT);
		}
	}
}

float ReLU(float x)
{
	return max(0.0, x);
}

void ForwardInputToFirstHidden(const uint sampleIndex)
{
	for (uint row = 0; row < LAYER_WIDTH; row++)
	{
		float sum = 0.0;
		for (uint col = 0; col < INPUT_FEATURE_COUNT; col++)
		{
			const float feature = neurons[(sampleIndex * INPUT_FEATURE_COUNT) + col];
			const float weight = weights[(col * LAYER_WIDTH) + row];
			sum += feature * weight;
		}
		sum += biases[row];
		sum = ReLU(sum);

		neurons[(BATCH_SIZE * INPUT_FEATURE_COUNT) + (sampleIndex * LAYER_WIDTH) + row] = sum;
	}
}

void ForwardHiddenToNextHidden(const uint sampleIndex, const uint hiddenLayerIndex)
{
}

void ForwardLastHiddenToOutput(const uint sampleIndex)
{
}

void Forward(const uint sampleIndex)
{
	ForwardInputToFirstHidden(sampleIndex);
	for (uint hiddenLayerIndex = 0; hiddenLayerIndex < LAYER_COUNT; hiddenLayerIndex++)
	{
		ForwardHiddenToNextHidden(sampleIndex, hiddenLayerIndex);
	}
	ForwardLastHiddenToOutput(sampleIndex);
}

void Forward()
{
	const uint samplesPerThread = BATCH_SIZE / gl_WorkGroupSize.x;
	for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
	{
		const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
		Forward(sampleIndex);
	}
}

void main()
{
	const uint batchIndex = gl_GlobalInvocationID.x;

	// Load and encode neural ray
	ivec2 imageCoords[BATCH_SIZE];
	for (uint sampleIndex = 0; sampleIndex < BATCH_SIZE; sampleIndex++)
	{
		const ivec2 imageCoord = BatchSampleToImageCoord(batchIndex, sampleIndex);
		imageCoords[sampleIndex] = imageCoord;

		vec3 rayOrigin;
		vec3 rayDir;
		LoadNeuralRayFromImages(imageCoord, rayOrigin, rayDir);

		EncodeRay(sampleIndex, rayOrigin, rayDir);
	}

	Forward();

	// Write neural ray color to image
	for (uint sampleIndex = 0; sampleIndex < BATCH_SIZE; sampleIndex++)
	{
		const uint sampleOffset = sampleIndex * 3;

		vec3 neuralRayColor;
		neuralRayColor.x = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 0];
		neuralRayColor.y = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 1];
		neuralRayColor.z = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 2];
		//neuralRayColor = vec3(0.2);
		
		imageStore(nrcNeuralRayColorImage, imageCoords[sampleIndex], vec4(neuralRayColor, 1.0));
	}
}
