#version 460
#include "common.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

// Row major
ivec2 BatchSampleToImageCoord(const uint batchIndex, const uint sampleIndex)
{
	const uint linearIndex = (batchIndex * BATCH_SIZE) + sampleIndex;
	const uint y = linearIndex / RENDER_WIDTH;
	const uint x = linearIndex % RENDER_WIDTH;
	const ivec2 imageCoord = ivec2(x, y);
	return imageCoord;
}

float ReLU(float x)
{
	return max(0.0, x);
}

void ForwardInputToFirstHidden(const uint sampleIndex)
{
	for (uint row = 0; row < LAYER_WIDTH; row++)
	{
		float sum = 0.0;
		for (uint col = 0; col < INPUT_FEATURE_COUNT; col++)
		{
			const float feature = neurons[(sampleIndex * INPUT_FEATURE_COUNT) + col];
			const float weight = weights[(col * LAYER_WIDTH) + row];
			sum += feature * weight;
		}
		sum += biases[row];
		sum = ReLU(sum);

		neurons[(BATCH_SIZE * INPUT_FEATURE_COUNT) + (sampleIndex * LAYER_WIDTH) + row] = sum;
	}
}

void ForwardHiddenToNextHidden(const uint sampleIndex, const uint hiddenLayerIndex)
{
	const uint inputNeuronsOffset = BATCH_SIZE * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * hiddenLayerIndex));
	const uint weightsOffset = (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * hiddenLayerIndex);
	const uint biasesOffset = LAYER_WIDTH * (hiddenLayerIndex + 1);
	const uint outputNeuronsOffset = inputNeuronsOffset + (BATCH_SIZE * LAYER_WIDTH);

	for (uint row = 0; row < LAYER_WIDTH; row++)
	{
		float sum = 0.0;
		for (uint col = 0; col < LAYER_WIDTH; col++)
		{
			const float feature = neurons[inputNeuronsOffset + (sampleIndex * LAYER_WIDTH) + col];
			const float weight = weights[weightsOffset + (col * LAYER_WIDTH) + row];
			sum += feature * weight;
		}
		sum += biases[biasesOffset + row];
		sum = ReLU(sum);

		neurons[outputNeuronsOffset + (sampleIndex * LAYER_WIDTH) + row] = sum;
	}
}

void ForwardLastHiddenToOutput(const uint sampleIndex)
{
	const uint inputNeuronsOffset = BATCH_SIZE * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * (LAYER_COUNT - 1)));
	const uint weightsOffset = (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * LAYER_COUNT);
	const uint biasesOffset = LAYER_WIDTH * LAYER_COUNT;
	const uint outputNeuronsOffset = inputNeuronsOffset + (BATCH_SIZE * LAYER_WIDTH);

	for (uint row = 0; row < 3; row++)
	{
		float sum = 0.0;
		for (uint col = 0; col < LAYER_WIDTH; col++)
		{
			const float feature = neurons[inputNeuronsOffset + (sampleIndex * LAYER_WIDTH) + col];
			const float weight = weights[weightsOffset + (col * 3) + row];
			sum += feature * weight;
		}
		sum += biases[biasesOffset + row];
		sum = ReLU(sum);

		neurons[outputNeuronsOffset + (sampleIndex * 3) + row] = sum;
	}
}

void Forward(const uint sampleIndex)
{
	ForwardInputToFirstHidden(sampleIndex);
	for (uint hiddenLayerIndex = 0; hiddenLayerIndex < LAYER_COUNT - 1; hiddenLayerIndex++)
	{
		ForwardHiddenToNextHidden(sampleIndex, hiddenLayerIndex);
	}
	ForwardLastHiddenToOutput(sampleIndex);
}

const uint samplesPerThread = BATCH_SIZE / gl_WorkGroupSize.x;

void Forward()
{
	for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
	{
		const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
		Forward(sampleIndex);
	}
}

void main()
{
	const uint batchIndex = gl_WorkGroupID.x;

	subgroupBarrier();
	Forward();
	subgroupBarrier();

	// Write neural ray color to image
	for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
	{
		const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
		const uint sampleOffset = sampleIndex * 3;
		const ivec2 imageCoord = BatchSampleToImageCoord(batchIndex, sampleIndex);

		vec3 neuralRayColor;
		neuralRayColor.x = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 0];
		neuralRayColor.y = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 1];
		neuralRayColor.z = neurons[OUTPUT_NEURONS_INDEX + sampleOffset + 2];
		
		//neuralRayColor = vec3(float(imageCoords[sampleIndex].x) / float(RENDER_WIDTH), float(imageCoords[sampleIndex].y) / float(RENDER_HEIGHT), 0.0);
		//neuralRayColor = vec3(1.0, 0.0, 0.0);

		imageStore(nrcNeuralRayColorImage, imageCoord, vec4(neuralRayColor, 1.0));
	}
}
