#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void StoreInRingBuffer(const vec3 pos, const vec3 dir)
{
	const uint prevHead = atomicAdd(nrcTrainRingHead, 1) % TRAIN_RING_BUF_SIZE;
	
	nrcTrainRingBuffer[prevHead].posX = pos.x;
	nrcTrainRingBuffer[prevHead].posY = pos.y;
	nrcTrainRingBuffer[prevHead].posZ = pos.z;

	nrcTrainRingBuffer[prevHead].dirX = dir.x;
	nrcTrainRingBuffer[prevHead].dirY = dir.y;
	nrcTrainRingBuffer[prevHead].dirZ = dir.z;
}

void LoadFromRingBuffer(out vec3 pos, out vec3 dir)
{
	const uint prevTail = atomicAdd(nrcTrainRingTail, 1) % TRAIN_RING_BUF_SIZE;

	pos.x = nrcTrainRingBuffer[prevTail].posX;
	pos.y = nrcTrainRingBuffer[prevTail].posY;
	pos.z = nrcTrainRingBuffer[prevTail].posZ;

	dir.x = nrcTrainRingBuffer[prevTail].dirX;
	dir.y = nrcTrainRingBuffer[prevTail].dirY;
	dir.z = nrcTrainRingBuffer[prevTail].dirZ;
}

void StoreNrcTrainData(const uint linearPixelIndex, const vec3 pos, const vec3 dir, vec3 target, const bool didScatter)
{
	// Norm pos
	const vec3 normPos = (pos / skySize) + (skySize / 2.0);

	// Calc dir
	const float theta = atan(dir.z, dir.x);
	const float normTheta = (theta / PI) + 0.5;
	const float phi = acos(dir.y / length(dir.xz));
	const float normPhi = phi / PI;

	// Store train input
	nrcTrainInput[linearPixelIndex].posX = normPos.x;
	nrcTrainInput[linearPixelIndex].posY = normPos.y;
	nrcTrainInput[linearPixelIndex].posZ = normPos.z;
	nrcTrainInput[linearPixelIndex].theta = normTheta;
	nrcTrainInput[linearPixelIndex].phi = normPhi;

	// Store train target
	//target = log(vec3(1.0) + target);
	target = min(vec3(8.0), target);
	
	nrcTrainTarget[linearPixelIndex].r = target.x;
	nrcTrainTarget[linearPixelIndex].g = target.y;
	nrcTrainTarget[linearPixelIndex].b = target.z;

	// If didScatter -> store in ring buffer
	if (didScatter) { StoreInRingBuffer(pos, dir); }
}

vec4 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
	vec3 scatteredLight = vec3(0.0);

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];
	
	vec3 currentPoint = entry;
	vec3 currentDir = rayDir;
	
	float factor = 1.0;

	bool volumeExit = false;

	for (int i = 0; i < TRAIN_RAY_LENGTH; i++)
	{
		// Find new point
		currentPoint = DeltaTrack(currentPoint, currentDir, volumeExit);
		if (volumeExit) { break; }
		
		// Proper weighting of light
		factor *= 0.5; // * 0.5 because L_s is being approximated by 2 samples

		// Lighting
		const vec3 sceneLighting = TraceScene(currentPoint, currentDir) * factor;
		scatteredLight += sceneLighting; // Phase and transmittance are IS

		// Find new dir by IS the PF
		currentDir = NewRayDir(currentDir, true);
	}

	return vec4(scatteredLight, factor);
}

void main()
{
	// Get image coord
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;
	const ivec2 trainImageCoord = ivec2(x, y);
	const ivec2 renderImageCoord = ivec2(float(trainImageCoord.x) * TRAIN_X_DIST, float(trainImageCoord.y) * TRAIN_Y_DIST);
	const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);

	//y = TRAIN_HEIGHT - y;

	// Setup random
	InitRandom(fragUV);

	// Get rayOrigin and rayDir for train ray
	vec3 rayOrigin = vec3(0.0);
	vec3 rayDir = normalize(vec3(1.0));
	
	const bool didScatter = imageLoad(primaryRayInfoImage, renderImageCoord).x == 1.0;
	if (didScatter) // Load from pixel
	{
		rayOrigin = imageLoad(nrcRayOriginImage, renderImageCoord).xyz;
		rayDir = imageLoad(nrcRayDirImage, renderImageCoord).xyz;
	}
	else if(TRAIN_RING_BUF_SIZE > 0) // Load from ring buffer
	{
		LoadFromRingBuffer(rayOrigin, rayDir);
	}
	
	// Calculate target
	vec3 target = vec3(0.0);
	for (uint i = 0; i < TRAIN_SPP; i++) { target += TracePath(rayOrigin, rayDir).xyz; }
	target /= float(TRAIN_SPP);

	// Calc index
	//const uint linearPixelIndex = (y * TRAIN_WIDTH) + x;

	const uint linearPixelIndex = GetTrainLinearPixelIndex(x, y, TRAIN_WIDTH, TRAIN_HEIGHT, TRAIN_BATCH_SIZE_HORIZONTAL, TRAIN_BATCH_SIZE_VERTICAL);
	const uint linearPixelIndexScaledToRender = GetTrainLinearPixelIndex(renderImageCoord.x, renderImageCoord.y, RENDER_WIDTH, RENDER_HEIGHT,
		uint(float(TRAIN_BATCH_SIZE_HORIZONTAL) * TRAIN_X_DIST), uint(float(TRAIN_BATCH_SIZE_VERTICAL) * TRAIN_Y_DIST));

	vec4 primaryRayColor = imageLoad(primaryRayColorImage, renderImageCoord);
	primaryRayColor.r += sqrt(float(linearPixelIndexScaledToRender)) / sqrt(float(RENDER_WIDTH * RENDER_HEIGHT));
	imageStore(primaryRayColorImage, renderImageCoord, primaryRayColor);

//	vec4 primaryRayColor = imageLoad(primaryRayColorImage, trainImageCoord);
//	primaryRayColor.r += sqrt(float(linearPixelIndex)) / sqrt(float(TRAIN_WIDTH * TRAIN_HEIGHT));
//	imageStore(primaryRayColorImage, trainImageCoord, primaryRayColor);

	// Store train data
	if (TRAIN_RING_BUF_SIZE > 0)
	{
		StoreNrcTrainData(linearPixelIndex, rayOrigin, rayDir, target, didScatter);
	}

	// Increment batch valid sample counter
	if (didScatter)
	{
		const uint trainBatchCountHorizontal = TRAIN_WIDTH / TRAIN_BATCH_SIZE_HORIZONTAL;
		const uint linearBatchIndex = y / TRAIN_BATCH_SIZE_VERTICAL * trainBatchCountHorizontal 
									+ x / TRAIN_BATCH_SIZE_HORIZONTAL;
		if (nrcTrainFilter[linearBatchIndex] == 0) { atomicAdd(nrcTrainFilter[linearBatchIndex], 1); }
	}
}
