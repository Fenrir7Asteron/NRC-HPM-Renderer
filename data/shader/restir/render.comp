#version 460
#define RESTIR
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void GenPath(const vec3 rayOrigin, const vec3 rayDir, out vec3 path[PATH_VERTEX_COUNT])
{
	path[0] = rayOrigin;

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];

	vec3 currentPoint = entry;
	vec3 lastPoint = entry;
	
	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	for (uint i = 0; i < PATH_VERTEX_COUNT; i++)
	{
		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;

			// Generate new direction
			currentDir = NewRayDir(currentDir);
		}

		path[i] = currentPoint;

		// Generate new point
		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = RandFloat(maxDistance);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}
}

vec4 ShadePath(const ivec2 imageCoord)
{
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;

	vec3 currentPoint;
	vec3 lastPoint = LoadPathVertex(imageCoord, 0);
	
	vec3 currentDir;
	vec3 lastDir = vec3(0.0);

	for (uint i = 1; i < PATH_VERTEX_COUNT; i++)
	{
		currentPoint = LoadPathVertex(imageCoord, i);
		currentDir = normalize(currentPoint - lastPoint);

		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			// Get scene lighting
			const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

			// Phase factor
			const float phase = 1.0; // Importance sampling

			// Transmittance calculation
			const vec3 s_int = density * sceneLighting * phase;
			const float t_r = GetTransmittance(currentPoint, lastPoint, 32);

			scatteredLight += transmittance * s_int;
			transmittance *= t_r;

			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;
		}
	}

	return vec4(scatteredLight, transmittance);
}

vec4 TracePath(const ivec2 imageCoord)
{	
	const vec4 pathOutput = ShadePath(imageCoord);
	return pathOutput;
}

void main()
{
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;
	const ivec2 imageCoord = ivec2(x, y);

	// Fraguv and world pos
	const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);

	// Setup random
	preRand = volumeData.random.x * fragUV.x;
	prePreRand = volumeData.random.y * fragUV.y;

	// Load pixel info
	const vec4 pixelInfo = imageLoad(pixelInfoImage, imageCoord);
	const vec3 backgroundColor = pixelInfo.xyz;
	const bool didScatter = pixelInfo.w == 1.0;

	// Shading
	vec4 primaryRayColor;
	if (didScatter)
	{
		primaryRayColor = TracePath(imageCoord);
	}
	else
	{
		primaryRayColor = vec4(vec3(0.0), 1.0);
	}

	if (primaryRayColor.w == 1.0)
	{
		primaryRayColor.xyz = backgroundColor;
	}

	const ivec2 invertedYImageCoord = ivec2(x, RENDER_HEIGHT - (y + 1));
	imageStore(outputImage, invertedYImageCoord, primaryRayColor);
}
